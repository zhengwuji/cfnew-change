import { connect } from 'cloudflare:sockets';

// --- ç¡¬ç¼–ç é…ç½® ---
const authToken = 'f64bdc57-0f54-4705-bf75-cfd646d98c06';
let fallbackAddress = '';
let fallbackPort = '443';
const socks5Config = '';
// æ‰‹åŠ¨æŒ‡å®šåœ°åŒºï¼ˆç•™ç©ºåˆ™è‡ªåŠ¨æ£€æµ‹ï¼Œå¯é€‰å€¼ï¼šUSã€SGã€JPã€HKã€KRã€DEã€SEã€NLã€FIã€GBï¼‰
const manualWorkerRegion = '';
// DçŸ­åœ°å€ï¼ˆè‡ªå®šä¹‰è·¯å¾„ï¼Œç•™ç©ºåˆ™ä½¿ç”¨UUIDè·¯å¾„ï¼Œæ”¯æŒå¤šçº§è·¯å¾„å¦‚ï¼šmypath æˆ– path/to/subï¼‰
const customPath = '';
// GitHubè®¢é˜…URLï¼ˆç¡¬ç¼–ç ï¼‰
const githubPreferredURL = 'https://raw.githubusercontent.com/qwer-search/bestip/refs/heads/main/kejilandbestip.txt';
// å¯ç”¨GitHubä¼˜é€‰IPï¼ˆtrueå¯ç”¨ï¼Œfalseç¦ç”¨ï¼‰
const enableGitHubPreferred = true;
// å¯ç”¨å…¶ä»–ä¼˜é€‰ï¼ˆåŸŸåä¼˜é€‰ï¼Œtrueå¯ç”¨ï¼Œfalseç¦ç”¨ï¼‰
const enableOtherPreferred = true;
// APIåœ°å€é…ç½®ï¼ˆè®¢é˜…è½¬æ¢æœåŠ¡ï¼‰
const apiBaseUrl = 'https://url.v1.mk/sub';

const directDomains = [
    { name: "cloudflare.182682.xyz", domain: "cloudflare.182682.xyz" }, 
    { name: "speed.marisalnc.com", domain: "speed.marisalnc.com" },
    { domain: "freeyx.cloudflare88.eu.org" }, { domain: "bestcf.top" }, 
    { domain: "cdn.2020111.xyz" }, { domain: "cfip.cfcdn.vip" },
    { domain: "cf.0sm.com" }, { domain: "cf.090227.xyz" }, 
    { domain: "cf.zhetengsha.eu.org" }, { domain: "cloudflare.9jy.cc" },
    { domain: "cf.zerone-cdn.pp.ua" }, { domain: "cfip.1323123.xyz" }, 
    { domain: "cnamefuckxxs.yuchen.icu" }, { domain: "cloudflare-ip.mofashi.ltd" },
    { domain: "115155.xyz" }, { domain: "cname.xirancdn.us" }, 
    { domain: "f3058171cad.002404.xyz" }, { domain: "8.889288.xyz" },
    { domain: "cdn.tzpro.xyz" }, { domain: "cf.877771.xyz" }, 
    { domain: "xn--b6gac.eu.org" }
];

const parsedSocks5Config = {};
const isSocksEnabled = false;

let enableRegionMatching = true;
let currentWorkerRegion = '';

const backupIPs = [
    { domain: 'ProxyIP.US.CMLiussss.net', region: 'US', regionCode: 'US', port: 443 },
    { domain: 'ProxyIP.SG.CMLiussss.net', region: 'SG', regionCode: 'SG', port: 443 },
    { domain: 'ProxyIP.JP.CMLiussss.net', region: 'JP', regionCode: 'JP', port: 443 },
    { domain: 'ProxyIP.HK.CMLiussss.net', region: 'HK', regionCode: 'HK', port: 443 },
    { domain: 'ProxyIP.KR.CMLiussss.net', region: 'KR', regionCode: 'KR', port: 443 },
    { domain: 'ProxyIP.DE.CMLiussss.net', region: 'DE', regionCode: 'DE', port: 443 },
    { domain: 'ProxyIP.SE.CMLiussss.net', region: 'SE', regionCode: 'SE', port: 443 },
    { domain: 'ProxyIP.NL.CMLiussss.net', region: 'NL', regionCode: 'NL', port: 443 },
    { domain: 'ProxyIP.FI.CMLiussss.net', region: 'FI', regionCode: 'FI', port: 443 },
    { domain: 'ProxyIP.GB.CMLiussss.net', region: 'GB', regionCode: 'GB', port: 443 }
];

const E_INVALID_DATA = atob('aW52YWxpZCBkYXRh');
const E_INVALID_USER = atob('aW52YWxpZCB1c2Vy');
const E_UNSUPPORTED_CMD = atob('Y29tbWFuZCBpcyBub3Qgc3VwcG9ydGVk');
const E_UDP_DNS_ONLY = atob('VURQIHByb3h5IG9ubHkgZW5hYmxlIGZvciBETlMgd2hpY2ggaXMgcG9ydCA1Mw==');
const E_INVALID_ADDR_TYPE = atob('aW52YWxpZCBhZGRyZXNzVHlwZQ==');
const E_EMPTY_ADDR = atob('YWRkcmVzc1ZhbHVlIGlzIGVtcHR5');
const E_WS_NOT_OPEN = atob('d2ViU29ja2V0LmVhZHlTdGF0ZSBpcyBub3Qgb3Blbg==');
const E_INVALID_ID_STR = atob('U3RyaW5naWZpZWQgaWRlbnRpZmllciBpcyBpbnZhbGlk');
const E_INVALID_SOCKS_ADDR = atob('SW52YWxpZCBTT0NLUyBhZGRyZXNzIGZvcm1hdA==');
const E_SOCKS_NO_METHOD = atob('bm8gYWNjZXB0YWJsZSBtZXRob2Rz');
const E_SOCKS_AUTH_NEEDED = atob('c29ja3Mgc2VydmVyIG5lZWRzIGF1dGg=');
const E_SOCKS_AUTH_FAIL = atob('ZmFpbCB0byBhdXRoIHNvY2tzIHNlcnZlcg==');
const E_SOCKS_CONN_FAIL = atob('ZmFpbCB0byBvcGVuIHNvY2tzIGNvbm5lY3Rpb24=');

const ADDRESS_TYPE_IPV4 = 1;
const ADDRESS_TYPE_URL = 2;
const ADDRESS_TYPE_IPV6 = 3;

async function detectWorkerRegion(request) {
    try {
        const cfCountry = request.cf?.country;
        if (cfCountry) {
            const countryToRegion = {
                'US': 'US', 'SG': 'SG', 'JP': 'JP', 'HK': 'HK', 'KR': 'KR',
                'DE': 'DE', 'SE': 'SE', 'NL': 'NL', 'FI': 'FI', 'GB': 'GB',
                'CN': 'HK', 'TW': 'HK', 'AU': 'SG', 'CA': 'US',
                'FR': 'DE', 'IT': 'DE', 'ES': 'DE', 'CH': 'DE',
                'AT': 'DE', 'BE': 'NL', 'DK': 'SE', 'NO': 'SE', 'IE': 'GB'
            };
            if (countryToRegion[cfCountry]) {
                return countryToRegion[cfCountry];
            }
        }
        return 'HK';
    } catch (error) {
        return 'HK';
    }
}

function getNearbyRegions(region) {
    const nearbyMap = {
        'US': ['SG', 'JP', 'HK', 'KR'],
        'SG': ['JP', 'HK', 'KR', 'US'],
        'JP': ['SG', 'HK', 'KR', 'US'],
        'HK': ['SG', 'JP', 'KR', 'US'],
        'KR': ['JP', 'HK', 'SG', 'US'],
        'DE': ['NL', 'GB', 'SE', 'FI'],
        'SE': ['DE', 'NL', 'FI', 'GB'],
        'NL': ['DE', 'GB', 'SE', 'FI'],
        'FI': ['SE', 'DE', 'NL', 'GB'],
        'GB': ['DE', 'NL', 'SE', 'FI']
    };
    return nearbyMap[region] || [];
}

function getAllRegionsByPriority(region) {
    const nearbyRegions = getNearbyRegions(region);
    const allRegions = ['US', 'SG', 'JP', 'HK', 'KR', 'DE', 'SE', 'NL', 'FI', 'GB'];
    return [region, ...nearbyRegions, ...allRegions.filter(r => r !== region && !nearbyRegions.includes(r))];
}

function getSmartRegionSelection(workerRegion, availableIPs) {
    if (!enableRegionMatching || !workerRegion) {
        return availableIPs;
    }
    const priorityRegions = getAllRegionsByPriority(workerRegion);
    const sortedIPs = [];
    for (const region of priorityRegions) {
        const regionIPs = availableIPs.filter(ip => ip.regionCode === region);
        sortedIPs.push(...regionIPs);
    }
    return sortedIPs;
}

async function getBestBackupIP(workerRegion = '') {
    if (backupIPs.length === 0) {
        return null;
    }
    const availableIPs = backupIPs.map(ip => ({ ...ip, available: true }));
    if (enableRegionMatching && workerRegion) {
        const sortedIPs = getSmartRegionSelection(workerRegion, availableIPs);
        if (sortedIPs.length > 0) {
            return sortedIPs[0];
        }
    }
    return availableIPs[0];
}

export default {
	async fetch(request, env, ctx) {
		try {
			const url = new URL(request.url);
			
			// æ‰‹åŠ¨æŒ‡å®šåœ°åŒºæˆ–è‡ªåŠ¨æ£€æµ‹ï¼ˆä»…ä½¿ç”¨ç¡¬ç¼–ç å˜é‡ï¼‰
			if (manualWorkerRegion && manualWorkerRegion.trim()) {
				currentWorkerRegion = manualWorkerRegion.trim().toUpperCase();
			} else {
				currentWorkerRegion = await detectWorkerRegion(request);
			}
			
			// æ ¹æ®åœ°åŒºæ™ºèƒ½é€‰æ‹©å¤‡ç”¨IPä½œä¸ºè®¿é—®å¤±è´¥æ—¶çš„å¤‡ç”¨ï¼ˆæ¯æ¬¡è¯·æ±‚éƒ½é‡æ–°é€‰æ‹©ï¼‰
			let currentFallbackAddress = fallbackAddress;
			let currentFallbackPort = fallbackPort;
			if (!currentFallbackAddress && currentWorkerRegion) {
				const bestBackupIP = await getBestBackupIP(currentWorkerRegion);
				if (bestBackupIP) {
					currentFallbackAddress = bestBackupIP.domain;
					currentFallbackPort = bestBackupIP.port.toString();
				}
			}

			if (request.headers.get('Upgrade') === 'websocket') {
				return await handleWsRequest(request, currentFallbackAddress, currentFallbackPort);
			} else if (request.method === 'GET') {
				// é¦–é¡µæç¤ºæœåŠ¡æ­£å¸¸
				if (url.pathname === '/') {
					const successHtml = `<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>æœåŠ¡æ­£å¸¸</title><style>body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;display:flex;justify-content:center;align-items:center;height:100vh;margin:0;background-color:#121212;color:#e0e0e0;text-align:center;}.container{padding:2rem;border-radius:8px;background-color:#1e1e1e;box-shadow:0 4px 6px rgba(0,0,0,0.1);}h1{color:#4caf50;}</style></head><body><div class="container"><h1>âœ… æœåŠ¡æ­£å¸¸</h1><p>è¯·ç»§ç»­åé¢çš„æ“ä½œã€‚</p></div></body></html>`;
					return new Response(successHtml, { status: 200, headers: { 'Content-Type': 'text/html; charset=utf-8' } });
				}
				
				// DçŸ­åœ°å€ï¼ˆè‡ªå®šä¹‰è·¯å¾„ï¼‰æ”¯æŒ
				if (customPath && customPath.trim()) {
					const cleanCustomPath = customPath.trim().startsWith('/') ? customPath.trim() : '/' + customPath.trim();
					const normalizedCustomPath = cleanCustomPath.endsWith('/') && cleanCustomPath.length > 1 ? cleanCustomPath.slice(0, -1) : cleanCustomPath;
					const normalizedPath = url.pathname.endsWith('/') && url.pathname.length > 1 ? url.pathname.slice(0, -1) : url.pathname;
					
					// è‡ªå®šä¹‰è·¯å¾„ - æ˜¾ç¤ºå›¾å½¢åŒ–ç•Œé¢
					if (normalizedPath === normalizedCustomPath) {
						return await handleSubscriptionPage(request, authToken);
					}
					
					// è‡ªå®šä¹‰è·¯å¾„/sub - è¿”å›è®¢é˜…
					if (normalizedPath === normalizedCustomPath + '/sub') {
						return await handleSubscriptionRequest(request, authToken, url);
					}
					
					// å¦‚æœè®¾ç½®äº†è‡ªå®šä¹‰è·¯å¾„ï¼ŒUUIDè·¯å¾„è¢«ç¦ç”¨
					if (url.pathname.length > 1 && url.pathname !== '/') {
						const user = url.pathname.replace(/\/$/, '').replace('/sub', '').substring(1);
						if (isValidFormat(user)) {
							return new Response(JSON.stringify({ 
								error: 'è®¿é—®è¢«æ‹’ç»',
								message: 'å½“å‰ Worker å·²å¯ç”¨è‡ªå®šä¹‰è·¯å¾„æ¨¡å¼ï¼ŒUUID è®¿é—®å·²ç¦ç”¨'
							}), { 
								status: 403,
								headers: { 'Content-Type': 'application/json; charset=utf-8' }
							});
						}
					}
				} else {
					// UUIDè·¯å¾„æ¨¡å¼
					// æ”¯æŒUUIDè·¯å¾„ï¼š/uuid - æ˜¾ç¤ºå›¾å½¢åŒ–ç•Œé¢
					if (url.pathname.length > 1 && url.pathname !== '/' && !url.pathname.includes('/sub')) {
						const uuid = url.pathname.replace(/\/$/, '').substring(1);
						if (isValidFormat(uuid)) {
							if (uuid === authToken) {
								return await handleSubscriptionPage(request, uuid);
							} else {
								return new Response('UUIDé”™è¯¯', { status: 403 });
							}
						}
					}
					// æ”¯æŒUUID/subè·¯å¾„ï¼š/uuid/sub - è¿”å›è®¢é˜…
					if (url.pathname.includes('/sub')) {
						const pathParts = url.pathname.split('/');
						if (pathParts.length === 2 && pathParts[1] === 'sub') {
							const uuid = pathParts[0].substring(1);
							if (isValidFormat(uuid)) {
								if (uuid === authToken) {
									return await handleSubscriptionRequest(request, uuid, url);
								} else {
									return new Response('UUIDé”™è¯¯', { status: 403 });
								}
							}
						}
					}
					// ä¿æŒå‘åå…¼å®¹
					if (url.pathname.toLowerCase().includes(`/${authToken}`)) {
						return await handleSubscriptionRequest(request, authToken);
					}
				}
			}
			return new Response('Not Found', { status: 404 });
		} catch (err) {
			return new Response(err.toString(), { status: 500 });
		}
	},
};

async function handleSubscriptionPage(request, uuid = null) {
	if (!uuid) uuid = authToken;
	
	const pageHtml = `<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>è®¢é˜…ä¸­å¿ƒ</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:"Courier New",monospace;background:#000;color:#00ff00;min-height:100vh;overflow-x:hidden;position:relative}
.matrix-bg{position:fixed;top:0;left:0;width:100%;height:100%;background:linear-gradient(45deg,#000 0%,#001100 50%,#000 100%);z-index:-1}
.matrix-rain{position:fixed;top:0;left:0;width:100%;height:100%;background:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,255,0,0.03) 2px,rgba(0,255,0,0.03) 4px);animation:matrix-fall 20s linear infinite;z-index:-1}
@keyframes matrix-fall{0%{transform:translateY(-100%)}100%{transform:translateY(100vh)}}
.container{max-width:900px;margin:0 auto;padding:20px;position:relative;z-index:1}
.header{text-align:center;margin-bottom:40px}
.title{font-size:3rem;font-weight:bold;color:#000000;margin-bottom:10px}
@keyframes matrix-glow{from{text-shadow:0 0 10px #00ff00,0 0 20px #00ff00,0 0 30px #00ff00}to{text-shadow:0 0 20px #00ff00,0 0 30px #00ff00,0 0 40px #00ff00}}
.subtitle{color:#00aa00;margin-bottom:30px;font-size:1.2rem}
.card{background:rgba(0,20,0,0.8);border:2px solid #00ff00;border-radius:0;padding:30px;margin-bottom:20px;box-shadow:0 0 20px rgba(0,255,0,0.3);position:relative}
.card::before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(45deg,transparent 49%,#00ff00 50%,transparent 51%);opacity:0.1;pointer-events:none}
.card-title{font-size:1.8rem;margin-bottom:20px;color:#00ff00;text-shadow:0 0 5px #00ff00}
.client-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:15px;margin:20px 0}
.client-btn{background:rgba(0,20,0,0.6);border:2px solid #00ff00;padding:15px 20px;color:#00ff00;font-family:"Courier New",monospace;font-weight:bold;cursor:pointer;transition:all 0.3s ease;text-align:center;position:relative;overflow:hidden}
.client-btn::before{content:"";position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(0,255,0,0.3),transparent);transition:left 0.5s ease}
.client-btn:hover::before{left:100%}
.client-btn:hover{background:rgba(0,255,0,0.2);box-shadow:0 0 15px #00ff00;transform:translateY(-2px)}
.generate-btn{background:rgba(0,255,0,0.1);border:2px solid #00ff00;padding:15px 30px;color:#00ff00;font-family:"Courier New",monospace;font-weight:bold;cursor:pointer;transition:all 0.3s ease;margin-right:15px}
.generate-btn:hover{background:rgba(0,255,0,0.3);box-shadow:0 0 20px #00ff00;transform:translateY(-2px)}
.subscription-url{background:rgba(0,0,0,0.8);border:1px solid #00ff00;padding:15px;word-break:break-all;font-family:"Courier New",monospace;color:#00ff00;margin-top:20px;display:none;box-shadow:inset 0 0 10px rgba(0,255,0,0.3)}
.matrix-text{position:fixed;top:20px;right:20px;color:#00ff00;font-family:"Courier New",monospace;font-size:0.8rem;opacity:0.6;animation:matrix-flicker 3s infinite}
@keyframes matrix-flicker{0%,100%{opacity:0.6}50%{opacity:1}}
</style>
</head>
<body>
<div class="matrix-bg"></div>
<div class="matrix-rain"></div>
<div class="matrix-text">ä»£ç†è®¢é˜…ä¸­å¿ƒç²¾ç®€ç‰ˆ v2.1</div>
<div class="container">
<div class="header">
<h1 class="title">ä»£ç†è®¢é˜…ä¸­å¿ƒ</h1>
<p class="subtitle">å¤šå®¢æˆ·ç«¯æ”¯æŒ â€¢ æ™ºèƒ½ä¼˜é€‰ â€¢ ä¸€é”®ç”Ÿæˆ</p>
</div>
<div class="card">
<h2 class="card-title">[ é€‰æ‹©å®¢æˆ·ç«¯ ]</h2>
<div class="client-grid">
<button class="client-btn" onclick="generateClientLink('clash','CLASH')">CLASH</button>
<button class="client-btn" onclick="generateClientLink('surge','SURGE')">SURGE</button>
<button class="client-btn" onclick="generateClientLink('singbox','SING-BOX')">SING-BOX</button>
<button class="client-btn" onclick="generateClientLink('loon','LOON')">LOON</button>
<button class="client-btn" onclick="generateClientLink('quanx','QUANTUMULT X')">QUANTUMULT X</button>
<button class="client-btn" onclick="generateClientLink('v2ray','V2RAY')">V2RAY</button>
<button class="client-btn" onclick="generateClientLink('v2ray','Shadowrocket')">Shadowrocket</button>
<button class="client-btn" onclick="generateClientLink('v2ray','V2RAYNG')">V2RAYNG</button>
<button class="client-btn" onclick="generateClientLink('v2ray','NEKORAY')">NEKORAY</button>
<button class="client-btn" onclick="generateClientLink('clash','STASH')">STASH</button>
</div>
<div class="subscription-url" id="clientSubscriptionUrl"></div>
</div>
<div class="card">
<h2 class="card-title">[ å¿«é€Ÿè·å– ]</h2>
<button class="generate-btn" onclick="getBase64Subscription()">è·å–è®¢é˜…é“¾æ¥</button>
<div class="subscription-url" id="base64SubscriptionUrl"></div>
</div>
<div class="card">
<h2 class="card-title">[ RDP åŠ é€Ÿé…ç½® ]</h2>
<div style="margin-bottom:20px">
<label style="display:block;margin-bottom:10px;color:#00ff00">è¿œç¨‹æœåŠ¡å™¨IP:</label>
<input type="text" id="rdpServerIP" placeholder="ä¾‹å¦‚: 192.168.1.100" style="width:100%;padding:12px;background:rgba(0,0,0,0.8);border:1px solid #00ff00;color:#00ff00;font-family:'Courier New',monospace" />
</div>
<div style="margin-bottom:20px">
<label style="display:block;margin-bottom:10px;color:#00ff00">RDP ç«¯å£:</label>
<input type="number" id="rdpServerPort" value="3389" placeholder="é»˜è®¤: 3389" style="width:100%;padding:12px;background:rgba(0,0,0,0.8);border:1px solid #00ff00;color:#00ff00;font-family:'Courier New',monospace" />
</div>
<div style="margin-bottom:20px">
<label style="display:block;margin-bottom:10px;color:#00ff00">æœ¬åœ°æ˜ å°„ç«¯å£:</label>
<input type="number" id="rdpLocalPort" value="13389" placeholder="é»˜è®¤: 13389" style="width:100%;padding:12px;background:rgba(0,0,0,0.8);border:1px solid #00ff00;color:#00ff00;font-family:'Courier New',monospace" />
</div>
<button class="generate-btn" onclick="generateRDPSubscription()">ğŸ–¥ï¸ ç”Ÿæˆ RDP åŠ é€Ÿè®¢é˜…</button>
<div class="subscription-url" id="rdpSubscriptionUrl"></div>
<div style="margin-top:15px;padding:10px;background:rgba(0,255,0,0.1);border-left:3px solid #00ff00;color:#00aa00;font-size:0.9rem">
<strong>ğŸ’¡ ä½¿ç”¨è¯´æ˜:</strong><br/>
1. å¡«å†™è¿œç¨‹æœåŠ¡å™¨IPå’ŒRDPç«¯å£<br/>
2. è®¾ç½®æœ¬åœ°æ˜ å°„ç«¯å£ï¼ˆé»˜è®¤13389ï¼‰<br/>
3. ç”Ÿæˆè®¢é˜…å¹¶å¯¼å…¥V2Rayå®¢æˆ·ç«¯<br/>
4. è¿æ¥åï¼Œåœ¨RDPå®¢æˆ·ç«¯è¾“å…¥: <code style="color:#00ff00">127.0.0.1:13389</code>
</div>
</div>
<div class="card">
<h2 class="card-title">[ ç›¸å…³é“¾æ¥ ]</h2>
<div style="text-align:center;margin:20px 0">
<a href="https://github.com/byJoey/cfnew" target="_blank" style="color:#00ff00;text-decoration:none;margin:0 20px;font-size:1.2rem;text-shadow:0 0 5px #00ff00">GitHub é¡¹ç›®</a>
<a href="https://www.youtube.com/@joeyblog" target="_blank" style="color:#00ff00;text-decoration:none;margin:0 20px;font-size:1.2rem;text-shadow:0 0 5px #00ff00">YouTube @joeyblog</a>
</div>
</div>
</div>
<script>
	var SUB_CONVERTER_URL="${apiBaseUrl}";
function tryOpenApp(schemeUrl,fallbackCallback,timeout){
timeout=timeout||2500;
var appOpened=false;
var callbackExecuted=false;
var startTime=Date.now();
var blurHandler=function(){
var elapsed=Date.now()-startTime;
if(elapsed<3000&&!callbackExecuted){appOpened=true;}
};
window.addEventListener('blur',blurHandler);
var hiddenHandler=function(){
var elapsed=Date.now()-startTime;
if(elapsed<3000&&!callbackExecuted){appOpened=true;}
};
document.addEventListener('visibilitychange',hiddenHandler);
var iframe=document.createElement('iframe');
iframe.style.display='none';
iframe.style.width='1px';
iframe.style.height='1px';
iframe.src=schemeUrl;
document.body.appendChild(iframe);
setTimeout(function(){
if(iframe.parentNode)iframe.parentNode.removeChild(iframe);
window.removeEventListener('blur',blurHandler);
document.removeEventListener('visibilitychange',hiddenHandler);
if(!callbackExecuted){
callbackExecuted=true;
if(!appOpened&&fallbackCallback)fallbackCallback();
}
},timeout);
}
function generateClientLink(clientType,clientName){
var currentUrl=window.location.href;
var subscriptionUrl=currentUrl+"/sub";
var schemeUrl='';
var displayName=clientName||'';
var finalUrl=subscriptionUrl;
if(clientType==='v2ray'){
finalUrl=subscriptionUrl;
document.getElementById("clientSubscriptionUrl").textContent=finalUrl;
document.getElementById("clientSubscriptionUrl").style.display="block";
if(clientName==='V2RAY'){
navigator.clipboard.writeText(finalUrl).then(function(){alert(displayName+" è®¢é˜…é“¾æ¥å·²å¤åˆ¶");});
}else if(clientName==='Shadowrocket'){
schemeUrl='shadowrocket://add/'+encodeURIComponent(finalUrl);
tryOpenApp(schemeUrl,function(){
navigator.clipboard.writeText(finalUrl).then(function(){alert(displayName+" è®¢é˜…é“¾æ¥å·²å¤åˆ¶");});
});
}else if(clientName==='V2RAYNG'){
schemeUrl='v2rayng://install?url='+encodeURIComponent(finalUrl);
tryOpenApp(schemeUrl,function(){
navigator.clipboard.writeText(finalUrl).then(function(){alert(displayName+" è®¢é˜…é“¾æ¥å·²å¤åˆ¶");});
});
}else if(clientName==='NEKORAY'){
schemeUrl='nekoray://install-config?url='+encodeURIComponent(finalUrl);
tryOpenApp(schemeUrl,function(){
navigator.clipboard.writeText(finalUrl).then(function(){alert(displayName+" è®¢é˜…é“¾æ¥å·²å¤åˆ¶");});
});
}
}else{
var encodedUrl=encodeURIComponent(subscriptionUrl);
finalUrl=SUB_CONVERTER_URL+"?target="+clientType+"&url="+encodedUrl+"&insert=false";
document.getElementById("clientSubscriptionUrl").textContent=finalUrl;
document.getElementById("clientSubscriptionUrl").style.display="block";
if(clientType==='clash'){
if(clientName==='STASH'){
schemeUrl='stash://install?url='+encodeURIComponent(finalUrl);
displayName='STASH';
}else{
schemeUrl='clash://install-config?url='+encodeURIComponent(finalUrl);
displayName='CLASH';
}
}else if(clientType==='surge'){
schemeUrl='surge:///install-config?url='+encodeURIComponent(finalUrl);
displayName='SURGE';
}else if(clientType==='singbox'){
schemeUrl='sing-box://install-config?url='+encodeURIComponent(finalUrl);
displayName='SING-BOX';
}else if(clientType==='loon'){
schemeUrl='loon://install?url='+encodeURIComponent(finalUrl);
displayName='LOON';
}else if(clientType==='quanx'){
schemeUrl='quantumult-x://install-config?url='+encodeURIComponent(finalUrl);
displayName='QUANTUMULT X';
}
if(schemeUrl){
tryOpenApp(schemeUrl,function(){
navigator.clipboard.writeText(finalUrl).then(function(){alert(displayName+" è®¢é˜…é“¾æ¥å·²å¤åˆ¶");});
});
}else{
navigator.clipboard.writeText(finalUrl).then(function(){alert(displayName+" è®¢é˜…é“¾æ¥å·²å¤åˆ¶");});
}
}
}
function getBase64Subscription(){
var currentUrl=window.location.href;
var subscriptionUrl=currentUrl+"/sub";
fetch(subscriptionUrl).then(function(response){return response.text();}).then(function(base64Content){
document.getElementById("base64SubscriptionUrl").textContent=base64Content;
document.getElementById("base64SubscriptionUrl").style.display="block";
navigator.clipboard.writeText(base64Content).then(function(){alert("Base64è®¢é˜…å†…å®¹å·²å¤åˆ¶");});
}).catch(function(error){alert("è·å–è®¢é˜…å¤±è´¥ï¼Œè¯·é‡è¯•");});
}
function generateRDPSubscription(){
var serverIP=document.getElementById("rdpServerIP").value.trim();
var serverPort=document.getElementById("rdpServerPort").value||"3389";
var localPort=document.getElementById("rdpLocalPort").value||"13389";
if(!serverIP){alert("è¯·è¾“å…¥è¿œç¨‹æœåŠ¡å™¨IP");return;}
var currentUrl=window.location.href;
var baseHost=window.location.hostname;
var rdpRemark="RDPåŠ é€Ÿ-"+serverIP+":"+serverPort+"â†’127.0.0.1:"+localPort;
var vlessLink="vless://00000000-0000-0000-0000-000000000000@"+baseHost+":443?encryption=none&security=tls&sni="+baseHost+"&fp=randomized&type=ws&host="+baseHost+"&path=%2F%3Fed%3D2048%26rdp%3D"+serverIP+"%3A"+serverPort+"%3A"+localPort+"#"+encodeURIComponent(rdpRemark);
var rdpSubscription=btoa(vlessLink);
document.getElementById("rdpSubscriptionUrl").textContent=rdpSubscription;
document.getElementById("rdpSubscriptionUrl").style.display="block";
navigator.clipboard.writeText(rdpSubscription).then(function(){alert("RDPåŠ é€Ÿè®¢é˜…å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼\\n\\né…ç½®å®Œæˆåï¼š\\n1. å¯¼å…¥V2Rayå®¢æˆ·ç«¯\\n2. è¿æ¥èŠ‚ç‚¹\\n3. RDPå®¢æˆ·ç«¯è¾“å…¥: 127.0.0.1:"+localPort);});
}
</script>
</body>
</html>`;
	
	return new Response(pageHtml, { 
		status: 200, 
		headers: { 'Content-Type': 'text/html; charset=utf-8' } 
	});
}

async function handleSubscriptionRequest(request, uuid, url = null) {
    if (!url) url = new URL(request.url);
    
    const finalLinks = [];
    const workerDomain = url.hostname;

    // æ·»åŠ åŸç”Ÿåœ°å€
    const nativeList = [{ ip: workerDomain, isp: 'åŸç”Ÿåœ°å€' }];
    finalLinks.push(...generateLinksFromSource(nativeList, uuid, workerDomain));

    // å…¶ä»–ä¼˜é€‰ï¼ˆåŸŸåä¼˜é€‰ï¼Œå—å¼€å…³æ§åˆ¶ï¼‰
    if (enableOtherPreferred) {
        const domainList = directDomains.map(d => ({ ip: d.domain, isp: d.name || d.domain }));
        finalLinks.push(...generateLinksFromSource(domainList, uuid, workerDomain));
    }

    // GitHubä¼˜é€‰IPï¼ˆå—å¼€å…³æ§åˆ¶ï¼‰
    if (enableGitHubPreferred) {
        const newIPList = await fetchAndParseNewIPs();
        if (newIPList.length > 0) {
            finalLinks.push(...generateLinksFromNewIPs(newIPList, uuid, workerDomain));
        }
    }

    if (finalLinks.length === 0) {
        const errorRemark = "æ‰€æœ‰èŠ‚ç‚¹è·å–å¤±è´¥";
        const errorLink = `vless://00000000-0000-0000-0000-000000000000@127.0.0.1:80?encryption=none&security=none&type=ws&host=error.com&path=%2F#${encodeURIComponent(errorRemark)}`;
        finalLinks.push(errorLink);
    }

    const subscriptionContent = btoa(finalLinks.join('\n'));
    
    return new Response(subscriptionContent, {
        headers: { 
            'Content-Type': 'text/plain; charset=utf-8',
            'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
        },
    });
}

function generateLinksFromSource(list, uuid, workerDomain) {
    const httpsPorts = [443];
    const links = [];
    const wsPath = '/?ed=2048';
    const proto = 'vless';

    list.forEach(item => {
        const nodeNameBase = item.isp.replace(/\s/g, '_');
        const safeIP = item.ip.includes(':') ? `[${item.ip}]` : item.ip;

        httpsPorts.forEach(port => {
            const wsNodeName = `${nodeNameBase}-${port}-WS-TLS`;
            const wsParams = new URLSearchParams({ 
                encryption: 'none', 
                security: 'tls', 
                sni: workerDomain, 
                fp: 'randomized', 
                type: 'ws', 
                host: workerDomain, 
                path: wsPath 
            });
            links.push(`${proto}://${uuid}@${safeIP}:${port}?${wsParams.toString()}#${encodeURIComponent(wsNodeName)}`);
        });
    });
    return links;
}

async function fetchAndParseNewIPs() {
    const url = githubPreferredURL;
    try {
        const response = await fetch(url);
        if (!response.ok) return [];
        const text = await response.text();
        const results = [];
        const lines = text.trim().replace(/\r/g, "").split('\n');
        const regex = /^([^:]+):(\d+)#(.*)$/;

        for (const line of lines) {
            const trimmedLine = line.trim();
            if (!trimmedLine) continue;
            const match = trimmedLine.match(regex);
            if (match) {
                results.push({
                    ip: match[1],
                    port: parseInt(match[2], 10),
                    name: match[3].trim() || match[1]
                });
            }
        }
        return results;
    } catch (error) {
        return [];
    }
}

function generateLinksFromNewIPs(list, uuid, workerDomain) {
    const links = [];
    const wsPath = '/?ed=2048';
    const proto = 'vless';

    list.forEach(item => {
        const nodeName = item.name;
        const safeIP = item.ip.includes(':') ? `[${item.ip}]` : item.ip;
        const params = {
            encryption: 'none',
            security: 'tls',
            sni: workerDomain,
            fp: 'randomized',
            type: 'ws',
            host: workerDomain,
            path: wsPath
        };
        const wsParams = new URLSearchParams(params);
        links.push(`${proto}://${uuid}@${safeIP}:${item.port}?${wsParams.toString()}#${encodeURIComponent(nodeName)}`);
    });
    return links;
}

// WebSocketå¤„ç†å‡½æ•°ï¼ˆç®€åŒ–ç‰ˆï¼‰
async function handleWsRequest(request, currentFallbackAddress = null, currentFallbackPort = null) {
    const wsPair = new WebSocketPair();
    const [clientSock, serverSock] = Object.values(wsPair);
    serverSock.accept();

    let remoteConnWrapper = { socket: null };
    let isDnsQuery = false;
    
    const fbAddr = currentFallbackAddress || fallbackAddress;
    const fbPort = currentFallbackPort || fallbackPort;

    const earlyData = request.headers.get('sec-websocket-protocol') || '';
    const readable = makeReadableStream(serverSock, earlyData);

    readable.pipeTo(new WritableStream({
        async write(chunk) {
            if (isDnsQuery) return await forwardUDP(chunk, serverSock, null);
            if (remoteConnWrapper.socket) {
                const writer = remoteConnWrapper.socket.writable.getWriter();
                await writer.write(chunk);
                writer.releaseLock();
                return;
            }
            const { hasError, message, addressType, port, hostname, rawIndex, version, isUDP } = parseWsPacketHeader(chunk, authToken);
            if (hasError) throw new Error(message);

            if (isUDP) {
                if (port === 53) isDnsQuery = true;
                else throw new Error(E_UDP_DNS_ONLY);
            }
            const respHeader = new Uint8Array([version[0], 0]);
            const rawData = chunk.slice(rawIndex);

            if (isDnsQuery) return forwardUDP(rawData, serverSock, respHeader);
            await forwardTCP(addressType, hostname, port, rawData, serverSock, respHeader, remoteConnWrapper, fbAddr, fbPort);
        },
    })).catch((err) => { console.log('WS Stream Error:', err); });

    return new Response(null, { status: 101, webSocket: clientSock });
}

async function forwardTCP(addrType, host, portNum, rawData, ws, respHeader, remoteConnWrapper, fbAddr = null, fbPort = null) {
    const fallbackAddr = fbAddr || fallbackAddress;
    const fallbackPortNum = fbPort || fallbackPort;
    
    async function connectAndSend(address, port) {
        const remoteSock = connect({ hostname: address, port: port });
        const writer = remoteSock.writable.getWriter();
        await writer.write(rawData);
        writer.releaseLock();
        return remoteSock;
    }
    async function retryConnection() {
        const newSocket = await connectAndSend(fallbackAddr || host, parseInt(fallbackPortNum, 10) || portNum);
        remoteConnWrapper.socket = newSocket;
        newSocket.closed.catch(() => {}).finally(() => closeSocketQuietly(ws));
        connectStreams(newSocket, ws, respHeader, null);
    }
    try {
        const initialSocket = await connectAndSend(host, portNum);
        remoteConnWrapper.socket = initialSocket;
        connectStreams(initialSocket, ws, respHeader, retryConnection);
    } catch (err) {
        console.log('Initial connection failed, trying fallback:', err);
        retryConnection();
    }
}

function parseWsPacketHeader(chunk, token) {
	if (chunk.byteLength < 24) return { hasError: true, message: E_INVALID_DATA };
	const version = new Uint8Array(chunk.slice(0, 1));
	if (formatIdentifier(new Uint8Array(chunk.slice(1, 17))) !== token) return { hasError: true, message: E_INVALID_USER };
	const optLen = new Uint8Array(chunk.slice(17, 18))[0];
	const cmd = new Uint8Array(chunk.slice(18 + optLen, 19 + optLen))[0];
	let isUDP = false;
	if (cmd === 1) {} else if (cmd === 2) { isUDP = true; } else { return { hasError: true, message: E_UNSUPPORTED_CMD }; }
	const portIdx = 19 + optLen;
	const port = new DataView(chunk.slice(portIdx, portIdx + 2)).getUint16(0);
	let addrIdx = portIdx + 2, addrLen = 0, addrValIdx = addrIdx + 1, hostname = '';
	const addressType = new Uint8Array(chunk.slice(addrIdx, addrValIdx))[0];
	switch (addressType) {
		case ADDRESS_TYPE_IPV4: addrLen = 4; hostname = new Uint8Array(chunk.slice(addrValIdx, addrValIdx + addrLen)).join('.'); break;
		case ADDRESS_TYPE_URL: addrLen = new Uint8Array(chunk.slice(addrValIdx, addrValIdx + 1))[0]; addrValIdx += 1; hostname = new TextDecoder().decode(chunk.slice(addrValIdx, addrValIdx + addrLen)); break;
		case ADDRESS_TYPE_IPV6: addrLen = 16; const ipv6 = []; const ipv6View = new DataView(chunk.slice(addrValIdx, addrValIdx + addrLen)); for (let i = 0; i < 8; i++) ipv6.push(ipv6View.getUint16(i * 2).toString(16)); hostname = ipv6.join(':'); break;
		default: return { hasError: true, message: `${E_INVALID_ADDR_TYPE}: ${addressType}` };
	}
	if (!hostname) return { hasError: true, message: `${E_EMPTY_ADDR}: ${addressType}` };
	return { hasError: false, addressType, port, hostname, isUDP, rawIndex: addrValIdx + addrLen, version };
}

function makeReadableStream(socket, earlyDataHeader) {
	let cancelled = false;
	return new ReadableStream({
		start(controller) {
			socket.addEventListener('message', (event) => { if (!cancelled) controller.enqueue(event.data); });
			socket.addEventListener('close', () => { if (!cancelled) { closeSocketQuietly(socket); controller.close(); } });
			socket.addEventListener('error', (err) => controller.error(err));
			const { earlyData, error } = base64ToArray(earlyDataHeader);
			if (error) controller.error(error); else if (earlyData) controller.enqueue(earlyData);
		},
		cancel() { cancelled = true; closeSocketQuietly(socket); }
	});
}

async function connectStreams(remoteSocket, webSocket, headerData, retryFunc) {
	let header = headerData, hasData = false;
	await remoteSocket.readable.pipeTo(
		new WritableStream({
			async write(chunk, controller) {
				hasData = true;
				if (webSocket.readyState !== 1) controller.error(E_WS_NOT_OPEN);
				if (header) { webSocket.send(await new Blob([header, chunk]).arrayBuffer()); header = null; } 
                else { webSocket.send(chunk); }
			},
			abort(reason) { console.error("Readable aborted:", reason); },
		})
	).catch((error) => { console.error("Stream connection error:", error); closeSocketQuietly(webSocket); });
	if (!hasData && retryFunc) retryFunc();
}

async function forwardUDP(udpChunk, webSocket, respHeader) {
	try {
		const tcpSocket = connect({ hostname: '8.8.4.4', port: 53 });
		let vlessHeader = respHeader;
		const writer = tcpSocket.writable.getWriter();
		await writer.write(udpChunk);
		writer.releaseLock();
		await tcpSocket.readable.pipeTo(new WritableStream({
			async write(chunk) {
				if (webSocket.readyState === 1) {
					if (vlessHeader) { webSocket.send(await new Blob([vlessHeader, chunk]).arrayBuffer()); vlessHeader = null; } 
                    else { webSocket.send(chunk); }
				}
			},
		}));
	} catch (error) { console.error(`DNS forward error: ${error.message}`); }
}

function base64ToArray(b64Str) {
    if (!b64Str) return { error: null };
    try { b64Str = b64Str.replace(/-/g, '+').replace(/_/g, '/'); return { earlyData: Uint8Array.from(atob(b64Str), (c) => c.charCodeAt(0)).buffer, error: null }; } 
    catch (error) { return { error }; }
}

function isValidFormat(uuid) { return /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(uuid); }

function closeSocketQuietly(socket) { try { if (socket.readyState === 1 || socket.readyState === 2) socket.close(); } catch (error) {} }

const hexTable = Array.from({ length: 256 }, (v, i) => (i + 256).toString(16).slice(1));

function formatIdentifier(arr, offset = 0) {
    const id = (hexTable[arr[offset]]+hexTable[arr[offset+1]]+hexTable[arr[offset+2]]+hexTable[arr[offset+3]]+"-"+hexTable[arr[offset+4]]+hexTable[arr[offset+5]]+"-"+hexTable[arr[offset+6]]+hexTable[arr[offset+7]]+"-"+hexTable[arr[offset+8]]+hexTable[arr[offset+9]]+"-"+hexTable[arr[offset+10]]+hexTable[arr[offset+11]]+hexTable[arr[offset+12]]+hexTable[arr[offset+13]]+hexTable[arr[offset+14]]+hexTable[arr[offset+15]]).toLowerCase();
    if (!isValidFormat(id)) throw new TypeError(E_INVALID_ID_STR);
    return id;
}
